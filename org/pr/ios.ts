import {message, warn, fail, danger} from "danger";

export async function iOSSafetyChecks() {

  const pr = danger.github.pr;
  const githubLabels = danger.github.issue.labels;

  // Core Data Model Safety Checks
  const targetReleaseBranch = pr.base.ref.startsWith("release/");
  const modifiedFiles = danger.git.modified_files;
  const changedFiles = modifiedFiles.concat(danger.git.deleted_files).concat(danger.git.created_files);
  const hasModifiedModel = changedFiles.some(path => path.includes(".xcdatamodeld"));
  if (targetReleaseBranch && hasModifiedModel) {
    warn("Core Data: Do not edit an existing Core Data model in a release branch unless it hasn't been released to testers yet. Instead create a new model version and merge back to develop soon.");
  }

  // Podfile should not reference commit hashes
  const podfileContents = await danger.github.utils.fileContents("Podfile");
  const matches = podfileContents.match(/^[^#]*:commit/gm);
  if (matches !== null) {
    const nonGutenbergMatches = matches.filter(m => !m.includes("gutenberg"));
    if (nonGutenbergMatches.length > 0) {
      fail("Podfile: reference to a commit hash");
    }
  }

  // If changes were made to the release notes, there must also be changes to the AppStoreStrings file.
  const hasModifiedReleaseNotes = modifiedFiles.some(f => f.endsWith("Resources/release_notes.txt"));
  const hasModifiedAppStoreStrings = modifiedFiles.some(f => f.includes("Resources/AppStoreStrings.po"));

  if (hasModifiedReleaseNotes && !hasModifiedAppStoreStrings) {
    warn("The AppStoreStrings.po file must be updated any time changes are made to release notes");
  }

  // Let users know that we're skipping tests on release PRs
  const isReleasePR = (githubLabels.length != 0) && githubLabels.some(label => label.name.includes("Releases"));
  if (isReleasePR) {
    message("This PR has the 'Releases' label: some checks will be skipped.");
  }

  // Changes to Resources/en.lproj/Localizable.strings should only be made on release branches since this file is
  // generated by our scripts
  const hasModifiedStrings = modifiedFiles.some(f => f.endsWith("Resources/en.lproj/Localizable.strings"));
  const isReleaseBranch = pr.head.ref.startsWith("release/");

  if (hasModifiedStrings && !isReleaseBranch && !isReleasePR) {
    warn("Localizable.strings should only be updated on release branches because it is generated automatically.");
  }
};

// Not exactly sure why, but in order for the multiple files + import setup
// to work we need to split the export of this function and its declaration
// as the default export. I'm guessing it has to do with how TypeScript
// resolves these?
export default iOSSafetyChecks
